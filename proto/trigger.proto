syntax = "proto3";

import "webhook.proto";

package trigger_proto;

enum TriggerStatus {
  TriggerStatus_UNKNOWN = 0;
  // A scheduled trigger thas has future runs
  SCHEDULED = 1;
  // A scheduled triggers that skips future runs
  PAUSED = 3;
  // Trigger can only be invoked manually 
  ON_DEMAND = 4;
  // Scheduled future with no future runs
  EXPIRED = 2;
  // Trigger that cannot be invoked anymore
  CANCELLED = 5;
}

message Recurring {
  string cron = 1;
  string timezone = 2;
  // The number of times this trigger should run. A value of 0, means that it never expires
  // output only
  optional uint64 limit = 3;
  // output only
  optional uint64 remaining = 4;
}

message Test {
  string _data = 1;
}

enum RetryPolicy {
  RetryPolicy_UNKNOWN = 0;
  SIMPLE = 1;
  EXPONENTIAL = 2;
}

message Payload {
  string content_type = 1;
  map<string, string> headers = 2;
  bytes body = 3;
}

message Emit {
  oneof emit {
    webhook_proto.Webhook webhook = 1;
    //Tunnel tunnel = 2;
  }
}

message RunAt {
  repeated string timepoints = 1;
  // output only
  optional uint64 remaining = 2;
}
message Schedule {
  oneof schedule {
    Recurring recurring = 1;
    // timepoint defined in iso 8601 format
    RunAt run_at = 2;
  }
}

message Trigger {
  string id = 1;
  string project_id = 2;
  /// User supplied identifier, unique per project
  optional string reference = 3;
  string name = 4;
  optional string description = 5;
  string created_at = 6;
  // output only
  optional string updated_at = 7;
  repeated Emit emit = 8;
  Payload payload = 9;
  Schedule schedule = 10;
  TriggerStatus status = 11;
}

message TriggerManifest {
  string id = 1;
  string project_id = 2;
  /// User supplied identifier, unique per project
  optional string reference = 3;
  string name = 4;
  optional string description = 5;
  string created_at = 6;
  optional string updated_at = 7;
  repeated Emit emit = 8;
  Schedule schedule = 9;
  TriggerStatus status = 10;
  optional string last_invoked_at = 11;
}

