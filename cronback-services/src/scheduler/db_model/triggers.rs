//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.3

use chrono::{DateTime, Utc};
use dto::{FromProto, IntoProto};
use lib::prelude::*;
use proto::events::TriggerMeta;
use sea_orm::entity::prelude::*;
use sea_orm::{DeriveActiveEnum, EnumIter};

use super::schedule::Schedule;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "triggers")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: TriggerId,
    // unique
    pub name: String,
    #[sea_orm(primary_key, auto_increment = false)]
    pub project_id: ValidShardedId<ProjectId>,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: Option<DateTime<Utc>>,
    pub payload: Option<Payload>,
    pub schedule: Option<Schedule>,
    pub action: Action,
    pub status: Status,
    pub last_ran_at: Option<DateTime<Utc>>,
}

impl Model {
    /// Metadata used in events tracking
    pub fn meta(&self) -> TriggerMeta {
        proto::events::TriggerMeta {
            trigger_id: Some(self.id.clone().into()),
            name: self.name.clone(),
        }
    }
}

impl PaginatedEntity for Entity {
    fn cursor_column() -> Self::Column {
        Column::Id
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    pub fn alive(&self) -> bool {
        self.status.alive()
    }

    pub fn update(
        &mut self,
        new_name: String,
        new_description: Option<String>,
        new_payload: Option<Payload>,
        new_schedule: Option<Schedule>,
        new_action: Action,
    ) {
        self.updated_at = Some(Utc::now());

        self.name = new_name;
        self.description = new_description;
        self.payload = new_payload;
        self.schedule = new_schedule;
        self.action = new_action;
        self.status = if self.schedule.is_some() {
            Status::Scheduled
        } else {
            Status::OnDemand
        };
        // NOTE: we leave last_ran_at as is.
    }

    pub fn estimated_future_runs(&self) -> Vec<DateTime<Utc>> {
        // The logic to determine the estimated future runs is follows:
        // If the trigger is not alive, we don't have future runs.
        //
        // This will not apply to _paused_ triggers. Those will still show that
        // they have future runs as normal.
        if !self.alive() {
            return vec![];
        }

        if let Some(ref schedule) = self.schedule {
            let after = self.last_ran_at.unwrap_or(self.created_at);
            // TODO make 5 configurable
            schedule.estimated_future_runs(after, 5)
        } else {
            vec![]
        }
    }
}

#[derive(
    Debug,
    FromProto,
    IntoProto,
    Default,
    Clone,
    PartialEq,
    Eq,
    EnumIter,
    DeriveActiveEnum,
)]
#[sea_orm(rs_type = "String", db_type = "String(None)")]
#[proto(target = "proto::triggers::TriggerStatus")]
pub enum Status {
    #[default]
    #[sea_orm(string_value = "Scheduled")]
    Scheduled,
    #[sea_orm(string_value = "OnDemand")]
    OnDemand,
    #[sea_orm(string_value = "Expired")]
    Expired,
    #[sea_orm(string_value = "Cancelled")]
    Cancelled,
    #[sea_orm(string_value = "Paused")]
    Paused,
}

impl Status {
    // Alive means that it should continue to live in the spinner map. A paused
    // trigger is considered alive, but it won't be rund. We will advance
    // its clock as if it was run though.
    pub fn alive(&self) -> bool {
        [Self::Scheduled, Self::Paused].contains(self)
    }

    pub fn cancelleable(&self) -> bool {
        [Self::Scheduled, Self::Paused, Self::OnDemand].contains(self)
    }

    pub fn as_operation(&self) -> String {
        match self {
            | Status::Scheduled => "resume",
            | Status::Expired => "expire",
            | Status::Cancelled => "cancel",
            | Status::Paused => "pause",
            | _ => "invalid",
        }
        .to_owned()
    }
}

impl ::std::convert::From<Model> for proto::triggers::Trigger {
    fn from(value: Model) -> Self {
        let estimated_future_runs = value
            .estimated_future_runs()
            .into_iter()
            .map(Into::into)
            .collect();
        Self {
            id: Some(value.id.into()),
            name: value.name,
            description: value.description.map(Into::into),
            created_at: Some(value.created_at.into()),
            updated_at: value.updated_at.map(Into::into),
            payload: value.payload.map(Into::into),
            schedule: value.schedule.map(Into::into),
            action: Some(value.action.into()),
            status: Some(value.status.into()),
            last_ran_at: value.last_ran_at.map(Into::into),
            estimated_future_runs,
        }
    }
}
