{
  "openapi": "3.1.0",
  "x-stoplight": {
    "id": "k35idp3ucv89r"
  },
  "info": {
    "title": "Cronback.me API",
    "version": "1.0",
    "contact": {
      "name": "Cronback Support",
      "url": "https://cronback.me",
      "email": "support@cronback.me"
    },
    "termsOfService": "https://cronback.me/terms",
    "description": "> pre-alpha release\n\n[Cronback](https://cronback.me) is a powerful, feature-rich API service designed for developers who need a reliable and flexible solution to schedule one-time, recurring cron, and on-demand webhooks. The service aims to streamline the process of integrating and automating webhook events into your applications or services, enabling seamless communication between various systems.\n\nKey Features:\n\n- One-Time Webhooks: Schedule a single webhook to be triggered at a specific time in the future, perfect for one-off events or reminders.\n\n- Recurring Cron Webhooks: Set up cron expressions to define custom recurring schedules for webhooks, allowing you to automate tasks such as daily reports, weekly updates, or monthly data synchronization.\n\n- On-Demand Webhooks: Trigger webhooks manually or programmatically at any time with the Cronback API, giving you full control over when your webhook events are executed.\n\n- Secure & Scalable Infrastructure: Built on a secure, high-performance infrastructure, Cronback is designed to handle large-scale webhook scheduling and execution, ensuring your webhooks are delivered promptly and consistently.\n\n- Robust Timezone Support: Schedule webhooks in any timezone to accommodate global operations, ensuring accurate timing of events for distributed teams and systems.\n\n\nWith [https://Cronback.me](https://cronback.me), you can say goodbye to the hassles of manual scheduling and tedious cron job management. Simply integrate Cronback into your applications and services, and let our API handle the rest.",
    "summary": "Scheduled, recurring, or on-demand triggers at scale"
  },
  "servers": [
    {
      "url": "https://api.cronback.me/v1",
      "description": "Production"
    },
    {
      "description": "Staging",
      "url": "https://api.jungle.cronback.me/v1"
    },
    {
      "url": "http://localhost:8888/v1",
      "description": "Local Development"
    }
  ],
  "paths": {
    "/triggers/{trigger_id}": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "trigger_id",
          "in": "path",
          "required": true,
          "description": "Trigger token"
        }
      ],
      "get": {
        "summary": "Get trigger",
        "responses": {
          "200": {
            "description": "Trigger exists",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Trigger"
                },
                "examples": {
                  "Example 1": {
                    "value": {
                      "id": "trig_ab1.01GWCXWB869BXW8Q2XZGE0JBQ6",
                      "owner_id": "acc_0FGWCXWB869BXWSQ2XZGE0JBA3",
                      "name": "my example trigger",
                      "created_at": "2023-03-25T17:43:23.654278298Z",
                      "reference_id": "string",
                      "description": "Periodically ping healthcheck.io",
                      "emit": [
                        {
                          "webhook": {
                            "url": "https://example.com/my-own-endpoint",
                            "http_method": "POST",
                            "timeout_s": 6.2,
                            "retry": {
                              "simple_retry": {
                                "max_num_attempts": 0,
                                "delay_s": 1
                              }
                            }
                          }
                        }
                      ],
                      "payload": {
                        "body": "{\"key\": \"value\"}",
                        "content_type": "application/json; charset=utf-8",
                        "headers": {}
                      },
                      "schedule": {
                        "recurring": {
                          "cron": "15 35 * * * *",
                          "timezone": "Europe/London",
                          "limit": 4,
                          "remaining": 0
                        }
                      },
                      "status": "active"
                    }
                  }
                }
              }
            },
            "headers": {
              "cronback-trace-id": {
                "schema": {
                  "type": "string"
                },
                "description": "A random trace id generated by cronback for debugging"
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/Error"
          },
          "404": {
            "$ref": "#/components/responses/Error"
          },
          "422": {
            "$ref": "#/components/responses/Error"
          }
        },
        "operationId": "get-trigger",
        "description": "Retrieve information about an existing installed trigger",
        "x-internal": false,
        "parameters": [],
        "tags": [
          "Triggers"
        ]
      }
    },
    "/triggers": {
      "get": {
        "summary": "List triggers",
        "operationId": "list-triggers",
        "description": "Returns a list of Triggers",
        "tags": [
          "Triggers"
        ],
        "parameters": [
          {
            "schema": {
              "type": "integer"
            },
            "in": "query",
            "name": "limit",
            "description": "A limit on the number of triggers to be returned. Limit can be a number between 1 and 100. Default limit is 20."
          },
          {
            "schema": {
              "type": "string"
            },
            "in": "query",
            "description": "A cursor for use in pagination. `before` is an object ID that defines your place in the list.",
            "name": "before"
          },
          {
            "schema": {
              "type": "string"
            },
            "in": "query",
            "name": "after",
            "description": "A cursor for use in pagination. `after` is an object ID that defines your place in the list."
          }
        ],
        "responses": {
          "200": {
            "description": "Returns a hash with `data` property that contains an array of up to `limit` Triggers, starting triggers specified in `after` or before triggers specified in `before`.\n\nObjects returned are sorted in reverse chronological orders (most recently created comes first).\n\nThis API will not fail (unless for authentication, or internal errors).",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/TriggerManifest"
                      }
                    },
                    "has_more": {
                      "type": "boolean",
                      "description": "`has_more` is true if limit was reached before returning all results."
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "security": [
          {
            "api_key": []
          }
        ]
      },
      "post": {
        "summary": "Install a new trigger",
        "operationId": "install-triggers",
        "responses": {
          "201": {
            "description": "Trigger has been installed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Trigger"
                },
                "examples": {}
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/Error"
          },
          "401": {
            "$ref": "#/components/responses/Error"
          },
          "409": {
            "$ref": "#/components/responses/Error"
          },
          "422": {
            "$ref": "#/components/responses/Error"
          }
        },
        "description": "Install a new trigger to cronback scheduler",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Trigger"
              },
              "examples": {}
            }
          }
        },
        "tags": [
          "triggers"
        ]
      },
      "parameters": []
    },
    "/invocations": {
      "get": {
        "summary": "List Invocations",
        "responses": {},
        "operationId": "get-invocations",
        "tags": [
          "Invocations"
        ],
        "parameters": [
          {
            "schema": {
              "type": "integer"
            },
            "in": "query",
            "name": "limit",
            "description": "A limit on the number of triggers to be returned. Limit can be a number between 1 and 100. Default limit is 20."
          },
          {
            "schema": {
              "type": "string"
            },
            "in": "query",
            "description": "A cursor for use in pagination. `before` is an object ID that defines your place in the list.",
            "name": "before"
          },
          {
            "schema": {
              "type": "string"
            },
            "in": "query",
            "name": "after",
            "description": "A cursor for use in pagination. `after` is an object ID that defines your place in the list."
          }
        ],
        "description": ""
      }
    },
    "/triggers/{trigger_id}/invocations": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "trigger_id",
          "in": "path",
          "required": true,
          "description": "Identifier of the trigger"
        }
      ],
      "get": {
        "summary": "Get invocations for a trigger",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Invocation"
                      }
                    },
                    "has_more": {
                      "type": "boolean",
                      "default": false,
                      "readOnly": true
                    }
                  }
                }
              }
            }
          }
        },
        "operationId": "get-triggers-trigger_id-invocations",
        "tags": [
          "Triggers",
          "Invocations"
        ],
        "parameters": [
          {
            "schema": {
              "type": "integer"
            },
            "in": "query",
            "name": "limit",
            "description": "A limit on the number of triggers to be returned. Limit can be a number between 1 and 100. Default limit is 20."
          },
          {
            "schema": {
              "type": "string"
            },
            "in": "query",
            "description": "A cursor for use in pagination. `before` is an object ID that defines your place in the list.",
            "name": "before"
          },
          {
            "schema": {
              "type": "string"
            },
            "in": "query",
            "name": "after",
            "description": "A cursor for use in pagination. `after` is an object ID that defines your place in the list."
          }
        ]
      }
    },
    "/invocations/{invocation_id}/attempts": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "invocation_id",
          "in": "path",
          "required": true
        }
      ],
      "get": {
        "summary": "List attempts for an invocation",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/WebhookAttempt"
                      }
                    },
                    "has_more": {
                      "type": "boolean",
                      "default": false,
                      "readOnly": true
                    }
                  }
                }
              }
            },
            "headers": {}
          }
        },
        "operationId": "get-invocations-invocation_id-attempts",
        "tags": [
          "Invocations"
        ],
        "parameters": [
          {
            "schema": {
              "type": "integer"
            },
            "in": "query",
            "name": "limit",
            "description": "A limit on the number of triggers to be returned. Limit can be a number between 1 and 100. Default limit is 20."
          },
          {
            "schema": {
              "type": "string"
            },
            "in": "query",
            "description": "A cursor for use in pagination. `before` is an object ID that defines your place in the list.",
            "name": "before"
          },
          {
            "schema": {
              "type": "string"
            },
            "in": "query",
            "name": "after",
            "description": "A cursor for use in pagination. `after` is an object ID that defines your place in the list."
          }
        ]
      }
    },
    "/invocations/{invocation_id}": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "invocation_id",
          "in": "path",
          "required": true
        }
      ],
      "get": {
        "summary": "Get an invocation",
        "responses": {},
        "operationId": "get-invocations-invocation_id",
        "tags": [
          "Invocations"
        ]
      }
    },
    "/triggers/{trigger_id}/cancel": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "trigger_id",
          "in": "path",
          "required": true
        }
      ],
      "post": {
        "summary": "Cancel trigger",
        "operationId": "post-triggers-trigger_id-cancel",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerManifest"
                }
              }
            }
          },
          "401": {
            "$ref": "#/components/responses/Error"
          },
          "404": {
            "$ref": "#/components/responses/Error"
          }
        },
        "tags": [
          "Triggers"
        ],
        "description": "Cancels a live trigger. The trigger must be in either `active` or `paused`"
      }
    },
    "/triggers/{trigger_id}/resume": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "trigger_id",
          "in": "path",
          "required": true
        }
      ],
      "post": {
        "summary": "Resume a paused trigger",
        "operationId": "post-triggers-trigger_id-resume",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerManifest"
                }
              }
            }
          }
        },
        "tags": [
          "Triggers"
        ],
        "description": "Resumes a `paused` trigger."
      }
    },
    "/triggers/{trigger_id}/invoke": {
      "parameters": [
        {
          "schema": {
            "type": "string"
          },
          "name": "trigger_id",
          "in": "path",
          "required": true
        }
      ],
      "post": {
        "summary": "Manually invoke a trigger",
        "operationId": "post-triggers-trigger_id-invoke",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Invocation"
                }
              }
            }
          }
        },
        "tags": [
          "Triggers"
        ],
        "description": "Creates an ad hoc invocation of the trigger. You can invoke triggers that are _not_ in the `cancelled` state.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "mode": {
                    "type": "string",
                    "enum": [
                      "sync",
                      "async"
                    ],
                    "default": "async"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Trigger": {
        "type": "object",
        "x-examples": {
          "Example 1": {
            "created_at": "2023-03-25T17:43:23.654278298Z",
            "description": "Periodically ping healthcheck.io",
            "emit": [
              {
                "webhook": {
                  "http_method": "GET",
                  "retry": null,
                  "timeout_s": 5,
                  "url": "https://hc-ping.com/812aaa48-08a5-45b7-a74c-e5baebc10ec1"
                }
              }
            ],
            "hidden_last_invoked_at": "2023-03-25T21:35:00.057112087Z",
            "id": "trig_ab1.01GWCXWB869BXW8Q2XZGE0JBQ6",
            "name": "Healthchecks.io",
            "owner_id": "ab1",
            "payload": {
              "body": "{}",
              "content_type": "application/json",
              "headers": {
                "test-header": "test-value"
              }
            },
            "schedule": {
              "recurring": {
                "cron": "0 35 * * * *",
                "limit": 0,
                "remaining": 0,
                "timezone": "Etc/UTC"
              }
            },
            "status": "active"
          }
        },
        "description": "Defines a scheduled or on-demand trigger.",
        "x-stoplight": {
          "id": "jg714xz8kn27b"
        },
        "examples": [],
        "properties": {
          "id": {
            "type": "string",
            "example": "trig_ab1.01GWCXWB869BXW8Q2XZGE0JBQ6",
            "description": "A unique identifier for the trigger",
            "readOnly": true
          },
          "project": {
            "type": "string",
            "example": "acc_0FGWCXWB869BXWSQ2XZGE0JBA3",
            "description": "The account owning this trigger",
            "readOnly": true
          },
          "name": {
            "type": "string",
            "example": "my example trigger",
            "description": "A human-readable name to identify the trigger. We will generate a name if this is not supplied."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "example": "2023-03-25T17:43:23.654278298Z",
            "description": "ISO8601 datetime when this trigger was installed",
            "readOnly": true
          },
          "reference": {
            "type": "string",
            "description": "Unique user-supplied identified for this trigger. This can be used as an idempotency key when creating triggers. Must be unique if set."
          },
          "description": {
            "type": "string",
            "example": "Periodically ping healthcheck.io",
            "description": "A human-readable description."
          },
          "emit": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/WebhookTarget"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/WebhookTarget"
                }
              }
            ]
          },
          "payload": {
            "$ref": "#/components/schemas/Payload"
          },
          "schedule": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/Cron"
              },
              {
                "$ref": "#/components/schemas/RunAt"
              }
            ]
          },
          "status": {
            "type": "string",
            "enum": [
              "active",
              "on_demand",
              "paused",
              "expired",
              "cancelled"
            ],
            "description": "Status of the trigger. \n- `active` triggers can be invoked either manually of according to their `trigger.schedule`\n- `on_demand` triggers can only be invoked manually, those do not have a schedule associated.\n- `paused` triggers will be invoked but will not emit anything.\n- `expired` triggers are scheduled triggers that exhausted their invocations or have no future timepoints.\n- `cancelled` triggers cannot be invoked. Those have been cancelled manually via the `/triggers/{trigger_id}/cancel` API.",
            "example": "active",
            "readOnly": true
          }
        },
        "required": [
          "emit"
        ]
      },
      "Payload": {
        "title": "Payload",
        "x-stoplight": {
          "id": "4r9satondb3ns"
        },
        "type": "object",
        "x-internal": true,
        "properties": {
          "body": {
            "type": "string",
            "x-stoplight": {
              "id": "u9dsnyz7t32li"
            },
            "description": "The body of the payload is sent as is when a trigger is emitted.",
            "example": "{\"key\": \"value\"}"
          },
          "content_type": {
            "type": "string",
            "x-stoplight": {
              "id": "nxz1bp0pppsm8"
            },
            "default": "application/json; charset=utf-8"
          },
          "headers": {
            "type": "object",
            "x-stoplight": {
              "id": "qsuqhdb5olzux"
            }
          }
        },
        "examples": [
          {
            "body": "{\"key\": \"value\"}",
            "content_type": "application/json; charset=utf-8",
            "headers": {
              "X-Custom-Header": "Custom-Value"
            }
          }
        ]
      },
      "Cron": {
        "title": "Recurring",
        "x-stoplight": {
          "id": "gaeky3l62bqwt"
        },
        "type": "object",
        "description": "Defines the recurring schedule",
        "x-internal": true,
        "properties": {
          "cron": {
            "type": "string",
            "x-stoplight": {
              "id": "i4c7adqqo0h26"
            },
            "example": "*/30 * * * * *",
            "description": "A cron-like string to specify when the trigger will be invoked. The cron pattern uses this format: `sec  min   hour   day-of-month   month   day-of-week   year`"
          },
          "timezone": {
            "type": "string",
            "x-stoplight": {
              "id": "p9al0cie3y72r"
            },
            "default": "Etc/UTC",
            "example": "Europe/London",
            "description": "A valid [IANA TZ Identifier](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) to qualify the cron pattern with"
          },
          "limit": {
            "type": "integer",
            "x-stoplight": {
              "id": "mfadwrgzmqo8q"
            },
            "default": 0,
            "format": "int64",
            "minimum": 0,
            "example": 4,
            "description": "The maximum number of invocations. The trigger's status will transition to `expired` automatically when no more invocations are left"
          },
          "remaining": {
            "type": "integer",
            "x-stoplight": {
              "id": "2d3nwf30r6s2h"
            },
            "default": 0,
            "description": "If limit is set, this will indicate how many future invocations this trigger still has before expiring",
            "readOnly": true
          }
        }
      },
      "WebhookTarget": {
        "title": "WebhookTarget",
        "x-stoplight": {
          "id": "cvqbxrub68rym"
        },
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "x-stoplight": {
              "id": "hplwwhhbgujsf"
            },
            "format": "uri",
            "example": "https://example.com/my-own-endpoint"
          },
          "http_method": {
            "type": "string",
            "x-stoplight": {
              "id": "iijb3i01l7yzu"
            },
            "enum": [
              "GET",
              "PUT",
              "PATCH",
              "HEAD",
              "DELETE",
              "POST"
            ],
            "default": "POST"
          },
          "timeout_s": {
            "type": "number",
            "x-stoplight": {
              "id": "988edpijqnr7k"
            },
            "format": "double",
            "default": 5,
            "example": 6.2,
            "minimum": 1,
            "exclusiveMaximum": 30,
            "description": "The number of seconds (use fractions for millis) to wait before considering the webhook attempt as `failed`"
          },
          "retry": {
            "x-stoplight": {
              "id": "nfrhe59pnh9v8"
            },
            "description": "The retry policy to use if attempts to execute this webhook fail",
            "oneOf": [
              {
                "$ref": "#/components/schemas/SimplyRetry"
              },
              {
                "$ref": "#/components/schemas/ExponentialBackoffRetry",
                "x-stoplight": {
                  "id": "nd1qrafgotilf"
                }
              }
            ]
          }
        },
        "required": [
          "url"
        ],
        "x-internal": true
      },
      "RunAt": {
        "title": "RunAt",
        "x-stoplight": {
          "id": "gwoegy0bco96d"
        },
        "type": "object",
        "examples": [
          {
            "timepoints": [
              "2023-03-26T12:49:41+00:00",
              "2023-03-26T12:49:41+00:00"
            ],
            "remaining": 1
          },
          {
            "timepoints": [
              "PT5M"
            ]
          }
        ],
        "x-internal": true,
        "properties": {
          "timepoints": {
            "type": "array",
            "x-stoplight": {
              "id": "pwbg3osqehonh"
            },
            "minItems": 1,
            "uniqueItems": true,
            "maxItems": 5000,
            "description": "ISO8601 datetime values (also accepts ISO8601 duration format as inpu, e.g. PT5M)",
            "items": {
              "x-stoplight": {
                "id": "7ig7mb74opass"
              },
              "type": "string",
              "format": "date-time",
              "example": "2023-03-26T12:49:41+00:00"
            }
          },
          "remaining": {
            "type": "integer",
            "x-stoplight": {
              "id": "c85h4py9obh4r"
            },
            "format": "int64",
            "readOnly": true
          }
        }
      },
      "ExponentialBackoffRetry": {
        "title": "ExponentialBackoffRetry",
        "x-stoplight": {
          "id": "cmnjvelmfykfa"
        },
        "type": "object",
        "description": "An exponential backoff retry policy",
        "x-internal": true,
        "properties": {
          "max_num_attempts": {
            "type": "integer",
            "x-stoplight": {
              "id": "h3xkmm43oqqo7"
            },
            "format": "int64",
            "minimum": 1,
            "description": "The maximum number of attempts before giving up",
            "example": 20
          },
          "delay_s": {
            "type": "number",
            "x-stoplight": {
              "id": "c7cuc75am2ewg"
            },
            "format": "double",
            "minimum": 1,
            "description": "The initial delay in seconds between attempts. This value is doubled on every subsequent attempt",
            "example": 30.3
          },
          "max_delay_s": {
            "type": "number",
            "x-stoplight": {
              "id": "bsvj0ygpn9nqv"
            },
            "format": "double",
            "minimum": 1,
            "description": "The upper cap for the delay. Delays are doubled on each attempt until it reaches `max_delay_s`",
            "example": 600
          },
          "type": {
            "type": "string",
            "default": "exponential_backoff"
          }
        }
      },
      "SimplyRetry": {
        "title": "SimplyRetry",
        "x-stoplight": {
          "id": "svb1o16ieshm2"
        },
        "type": "object",
        "description": "A simple retry policy (every X seconds)",
        "x-internal": true,
        "properties": {
          "max_num_attempts": {
            "type": "integer",
            "x-stoplight": {
              "id": "uxi4p9ug8m52q"
            },
            "format": "int32",
            "description": "The maximum number of attempts before giving up"
          },
          "delay_s": {
            "type": "number",
            "x-stoplight": {
              "id": "a94kssf1bzlb4"
            },
            "format": "float",
            "minimum": 1,
            "description": "The delay in seconds between every attempt",
            "example": 30.5
          },
          "type": {
            "type": "string",
            "default": "simple"
          }
        }
      },
      "TriggerManifest": {
        "title": "TriggerManifest",
        "x-stoplight": {
          "id": "crf0j8v9wzj63"
        },
        "type": "object",
        "x-examples": {
          "Example 1": {
            "created_at": "2023-03-25T17:43:23.654278298Z",
            "description": "Periodically ping healthcheck.io",
            "emit": [
              {
                "webhook": {
                  "http_method": "GET",
                  "retry": null,
                  "timeout_s": 5,
                  "url": "https://hc-ping.com/812aaa48-08a5-45b7-a74c-e5baebc10ec1"
                }
              }
            ],
            "hidden_last_invoked_at": "2023-03-25T21:35:00.057112087Z",
            "id": "trig_ab1.01GWCXWB869BXW8Q2XZGE0JBQ6",
            "name": "Healthchecks.io",
            "owner_id": "ab1",
            "payload": {
              "body": "{}",
              "content_type": "application/json",
              "headers": {
                "test-header": "test-value"
              }
            },
            "schedule": {
              "recurring": {
                "cron": "0 35 * * * *",
                "limit": 0,
                "remaining": 0,
                "timezone": "Etc/UTC"
              }
            },
            "status": "active"
          }
        },
        "description": "Defines a scheduled or on-demand trigger.",
        "examples": [],
        "properties": {
          "id": {
            "type": "string",
            "example": "trig_ab1.01GWCXWB869BXW8Q2XZGE0JBQ6",
            "description": "A unique identifier for the trigger",
            "readOnly": true
          },
          "project": {
            "type": "string",
            "example": "prj_0FGWCXWB869BXWSQ2XZGE0JBA3",
            "description": "The account owning this trigger",
            "readOnly": true
          },
          "name": {
            "type": "string",
            "example": "my example trigger",
            "description": "A human-readable name to identify the trigger. This doesn't need to be unique but we recommend picking unique names to avoid confusion"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "example": "2023-03-25T17:43:23.654278298Z",
            "description": "ISO8601 datetime when this trigger was installed",
            "readOnly": true
          },
          "reference": {
            "type": "string",
            "description": "Unique user-supplied identified for this trigger. This can be used as an idempotency key when creating triggers. Must be unique if set.",
            "example": "my-own-trigger"
          },
          "description": {
            "type": "string",
            "example": "Periodically ping healthcheck.io",
            "description": "A human-readable description."
          },
          "schedule": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/Cron"
              },
              {
                "$ref": "#/components/schemas/RunAt"
              }
            ]
          },
          "status": {
            "type": "string",
            "enum": [
              "active",
              "paused",
              "expired",
              "cancelled"
            ],
            "description": "Status of the trigger. \n- `active` triggers can be invoked either manually of according to their `trigger.schedule`\n- `paused` triggers will be invoked but will not emit anything.\n- `expired` triggers are scheduled triggers that exhausted their invocations or have no future timepoints.\n- `cancelled` triggers cannot be invoked. Those have been cancelled manually via the `/triggers/{trigger_id}/cancel` API.",
            "example": "active",
            "readOnly": true
          },
          "last_invoked_at": {
            "type": "string",
            "description": "ISO8601 datetime when this trigger was last invoked",
            "example": "2023-03-25T17:43:23.654278298Z"
          }
        }
      },
      "Invocation": {
        "title": "Invocation",
        "x-stoplight": {
          "id": "mcl1jeypmouci"
        },
        "type": "object",
        "examples": [],
        "properties": {
          "id": {
            "type": "string",
            "example": "inv_054001GXGVN9PHG2ZHNF28A7F81NYG",
            "readOnly": true
          },
          "trigger": {
            "type": "string",
            "example": "trig_054001GXGVMVJDS09N9TQK37TB95B5",
            "readOnly": true
          },
          "project": {
            "type": "string",
            "example": "prj_0FGWCXWB869BXWSQ2XZGE0JBA3",
            "readOnly": true
          },
          "created_at": {
            "type": "string",
            "example": "2023-03-25T17:43:23.654278298Z",
            "format": "date-time",
            "readOnly": true
          },
          "status": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InvocationStatus"
            }
          }
        }
      },
      "WebhookAttempt": {
        "title": "InvocationAttempt",
        "x-stoplight": {
          "id": "9s68v5iiffjv7"
        },
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "att_054001GXBF3E9MDBACQVCCY6D5E3MN",
            "readOnly": true
          },
          "invocation": {
            "type": "string",
            "example": "inv_054001GXBF2FAYW9S8N8Y4Y3E4R4N9",
            "readOnly": true
          },
          "trigger": {
            "type": "string",
            "example": "trig_054001GXBF2A0BMDXEVB6GF4FF4BQN",
            "readOnly": true
          },
          "project": {
            "type": "string",
            "example": "prj_054001GXBF3E9MDBACQVCCY6D5E3MN",
            "readOnly": true
          },
          "status": {
            "type": "string",
            "enum": [
              "succeeded",
              "failed"
            ],
            "example": "succeeded",
            "readOnly": true
          },
          "details": {
            "type": "object",
            "properties": {
              "response_code": {
                "type": "integer",
                "example": 200
              },
              "response_latency_s": {
                "type": "number",
                "format": "double",
                "example": 0.4
              },
              "error_message": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          },
          "created_at": {
            "type": "string",
            "example": "2023-03-25T17:43:23.654278298Z",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "InvocationStatus": {
        "title": "WebhookStatus",
        "x-stoplight": {
          "id": "rtwpwqwefad1t"
        },
        "type": "object",
        "properties": {
          "delivery_status": {
            "type": "string",
            "enum": [
              "attempting",
              "succeeded",
              "failed"
            ],
            "example": "succeeded",
            "readOnly": true
          },
          "type": {
            "type": "string",
            "example": "webhook",
            "default": "webhook",
            "readOnly": true
          },
          "url": {
            "type": "string",
            "example": "http://myendpoint.com/endpoint",
            "readOnly": true
          },
          "http_method": {
            "type": "string",
            "enum": [
              "POST",
              "GET",
              "HEAD",
              "PATCH",
              "PUT",
              "DELETE"
            ],
            "default": "POST",
            "readOnly": true
          },
          "timeout_s": {
            "type": "number",
            "format": "float",
            "example": 5.5,
            "readOnly": true
          },
          "retry": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimplyRetry"
              },
              {
                "$ref": "#/components/schemas/ExponentialBackoffRetry"
              }
            ]
          }
        }
      }
    },
    "securitySchemes": {
      "api_key": {
        "type": "http",
        "scheme": "bearer",
        "description": "API secret key acquired from cronback admin API"
      }
    },
    "requestBodies": {},
    "responses": {
      "Error": {
        "description": "An error has occurred. The error body contains information about what went wrong.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "message": {
                  "type": "string",
                  "description": "A human readable description of the error",
                  "readOnly": true
                },
                "params": {
                  "type": "object",
                  "description": "This describes the segments of the JSON inputs that has validation errors. The key is the full path `emit[0].timeout_s` and the value is an array of the different validation failures.\n",
                  "properties": {
                    "key": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                }
              },
              "required": [
                "message"
              ]
            },
            "examples": {
              "Validation Error (422)": {
                "value": {
                  "message": "Request body has failed validation",
                  "params": {
                    "emit[0].timeout_s": [
                      "Timeout must be between 1.0 and 30.0 seconds"
                    ]
                  }
                }
              },
              "Trigger Not Found": {
                "value": {
                  "message": "Resource requested was not found: trig_054001GXBF2A0BMDXEVB6GF4FF4BQN"
                }
              }
            }
          }
        },
        "headers": {
          "cronback-request-id": {
            "schema": {
              "type": "string"
            },
            "description": "A request Id that can be used to debug errors through support channels."
          }
        }
      }
    }
  },
  "security": [
    {
      "api_key": []
    }
  ]
}