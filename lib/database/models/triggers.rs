//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.3

use std::collections::HashMap;

use chrono::{DateTime, FixedOffset, Utc};
use dto::{FromProto, IntoProto};
use sea_orm::entity::prelude::*;
use sea_orm::{DeriveActiveEnum, EnumIter, FromJsonQueryResult};
use serde::{Deserialize, Serialize};

use crate::model::ValidShardedId;
use crate::types::{ProjectId, TriggerId, Webhook};

#[derive(Copy, Clone, Default, Debug, DeriveEntity)]
pub struct Entity;

impl EntityName for Entity {
    fn table_name(&self) -> &str {
        "triggers"
    }
}

#[derive(
    Clone, IntoProto, Debug, PartialEq, DeriveModel, DeriveActiveModel, Eq,
)]
#[proto(target = "proto::trigger_proto::Trigger")]
pub struct Model {
    #[proto(skip)]
    pub id: TriggerId,
    // unique
    pub name: String,
    #[proto(skip)]
    pub project_id: ValidShardedId<ProjectId>,
    pub description: Option<String>,
    #[proto(required)]
    pub created_at: DateTime<Utc>,
    pub updated_at: Option<DateTime<Utc>>,
    pub payload: Option<Payload>,
    pub schedule: Option<Schedule>,
    #[proto(required)]
    pub action: Action,
    #[proto(required)]
    pub status: Status,
    pub last_ran_at: Option<DateTime<Utc>>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]
pub enum Column {
    Id,
    Name,
    ProjectId,
    Description,
    CreatedAt,
    UpdatedAt,
    Payload,
    Schedule,
    Action,
    Status,
    LastRanAt,
}

#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]
pub enum PrimaryKey {
    Name,
    ProjectId,
}

impl PrimaryKeyTrait for PrimaryKey {
    type ValueType = (String, String);

    fn auto_increment() -> bool {
        false
    }
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {}

impl ColumnTrait for Column {
    type EntityName = Entity;

    fn def(&self) -> ColumnDef {
        match self {
            | Self::Id => ColumnType::String(None).def(),
            | Self::Name => ColumnType::String(None).def(),
            | Self::ProjectId => ColumnType::String(None).def(),
            | Self::Description => ColumnType::String(None).def().null(),
            | Self::CreatedAt => ColumnType::String(None).def(),
            | Self::UpdatedAt => ColumnType::String(None).def(),
            | Self::Payload => ColumnType::String(None).def().null(),
            | Self::Schedule => ColumnType::String(None).def().null(),
            | Self::Action => ColumnType::String(None).def().null(),
            | Self::Status => ColumnType::String(None).def(),
            | Self::LastRanAt => ColumnType::String(None).def().null(),
        }
    }
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        panic!("No RelationDef")
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    pub fn alive(&self) -> bool {
        self.status.alive()
    }

    pub fn update(
        &mut self,
        new_name: String,
        new_description: Option<String>,
        new_payload: Option<Payload>,
        new_schedule: Option<Schedule>,
        new_action: Action,
    ) {
        self.updated_at = Some(Utc::now());

        self.name = new_name;
        self.description = new_description;
        self.payload = new_payload;
        self.schedule = new_schedule;
        self.action = new_action;
        self.status = if self.schedule.is_some() {
            Status::Scheduled
        } else {
            Status::OnDemand
        };
        // NOTE: we leave last_ran_at as is.
    }
}

#[derive(
    Debug,
    FromProto,
    IntoProto,
    Default,
    Clone,
    PartialEq,
    Eq,
    EnumIter,
    DeriveActiveEnum,
)]
#[sea_orm(rs_type = "String", db_type = "String(None)")]
#[proto(target = "proto::trigger_proto::TriggerStatus")]
pub enum Status {
    #[default]
    #[sea_orm(string_value = "Scheduled")]
    Scheduled,
    #[sea_orm(string_value = "OnDemand")]
    OnDemand,
    #[sea_orm(string_value = "Expired")]
    Expired,
    #[sea_orm(string_value = "Cancelled")]
    Cancelled,
    #[sea_orm(string_value = "Paused")]
    Paused,
}

impl Status {
    // Alive means that it should continue to live in the spinner map. A paused
    // trigger is considered alive, but it won't be rund. We will advance
    // its clock as if it was run though.
    pub fn alive(&self) -> bool {
        [Self::Scheduled, Self::Paused].contains(self)
    }

    pub fn cancelleable(&self) -> bool {
        [Self::Scheduled, Self::Paused, Self::OnDemand].contains(self)
    }

    pub fn as_operation(&self) -> String {
        match self {
            | Status::Scheduled => "resume",
            | Status::Expired => "expire",
            | Status::Cancelled => "cancel",
            | Status::Paused => "pause",
            | _ => "invalid",
        }
        .to_owned()
    }
}

#[derive(
    Debug,
    Clone,
    FromProto,
    IntoProto,
    Serialize,
    Deserialize,
    PartialEq,
    Eq,
    FromJsonQueryResult,
)]
#[proto(target = "proto::trigger_proto::Schedule")]
pub enum Schedule {
    Recurring(Recurring),
    RunAt(RunAt),
}

#[derive(
    Debug,
    IntoProto,
    FromProto,
    Default,
    Clone,
    Serialize,
    Deserialize,
    PartialEq,
    Eq,
)]
#[proto(target = "proto::trigger_proto::RunAt")]
pub struct RunAt {
    pub timepoints: Vec<DateTime<FixedOffset>>,
    pub remaining: Option<u64>,
}

#[derive(
    Debug, IntoProto, FromProto, Clone, Serialize, Deserialize, PartialEq, Eq,
)]
#[proto(target = "proto::trigger_proto::Recurring")]
pub struct Recurring {
    pub cron: String,
    pub timezone: String,
    pub limit: Option<u64>,
    pub remaining: Option<u64>,
}

#[derive(
    Debug,
    IntoProto,
    FromProto,
    Clone,
    Serialize,
    Deserialize,
    PartialEq,
    Eq,
    FromJsonQueryResult,
)]
#[proto(target = "proto::trigger_proto::Action", non_exhaustive)]
pub enum Action {
    #[proto(skip)]
    Event(Event),
    Webhook(Webhook),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Event {
    event: String,
}

#[derive(
    Debug,
    Clone,
    FromProto,
    IntoProto,
    Serialize,
    Deserialize,
    PartialEq,
    Eq,
    FromJsonQueryResult,
)]
#[proto(target = "proto::trigger_proto::Payload")]
pub struct Payload {
    pub headers: HashMap<String, String>,
    pub content_type: String,
    #[proto(map_from_proto = "string_from_bytes")]
    pub body: String,
}

fn string_from_bytes(input: Vec<u8>) -> String {
    String::from_utf8(input).unwrap()
}
